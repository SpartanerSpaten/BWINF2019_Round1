\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}

%\graphicspath{ {../resources/} }

\begin{document}

\title{Telepaartie}
\author{Tassilo Tanneberger}

\maketitle

\section*{Ideen des Algorithmus}

\subsection*{ Finden der LLL}

Eine LLL kann nur entstehen wenn dafor zwei Spalten die gleiche anzahl Objekte beinhalten(a,b,c \dots Spalten) \( a = b\) Somit würde auch gleich einen Schritt zu vor gelten z.B 
\begin{equation}
	((2a = b \wedge a < c)  \oplus (2b = a \wedge b < c)) \oplus ((3a = b)  \oplus (3b = a))
\end{equation}

Mit diesem Wissen können wir mögliche LLLs zwei Schichten voraussagen. Zudem möchte ich noch kurz darauf aufmerksam machen das \(a>c\) oder \(b > c\) bei. \( \leq \) würde Regel 1.) greifen. Diese aufgestellten Beobachtungen helfen uns nun die zu untersuchenden Möglichkeit, um zwei Schichten immer zu reduzieren.

\subsection*{ Darstellung als Baum}

Die einzig wirklich sinnvolle datenstrukturelle Darstellung ist als Baum. Der folgende Eigenschaften besitzt: \newline

\(max_c\)\dots 				Maximale Anzahl Kinder und Kanten die ein Knoten hatt. \newline
\(collumns\)\dots 			Anzahl Spalten ( Boxen ) \newline
\(max_k\)\dots				Maximale anzahl an Knoten.  \newline
\(N\)\dots    					Anzahl der Schichten bis LLL gefunden wird

\begin{equation}
	max_c =  \sum \limits_{i=0}^N  i
\end{equation}

Das sind natürlich nur Worst Case Betrachtungen und mit intelligentem z.B Ausschließen von Doppelten lässt sich die gesamt Anzahl Knoten stark minimieren. Somit ergibt sich für Anzahl der Knoten im gesamten Baum die Funktion: \newline

\begin{equation}
	max_k =  \sum \limits_{i=1}^N  (max_c ^ i)
\end{equation}

Wie schon im ersten Abschnitt angesprochen können wir das N um zwei Reduzieren weil wir schon nach den Kanten suchen die diese Eigenschaften erfüllen und somit auf Garantie zur LLL führen.

\subsection*{ Suchen }


Auch wenn die Datenstruktur "Baum" immer sehr einladend ist rekursiv zu arbeiten (Suchen) ist sie für unseren Fall hier äußerst ungeeignet da wir damit sehr viele ungenutzte Knoten erzeugen, was sehr unperformant ist. Weswegen wir alle Kinder aller Knoten einer Schicht erzeugen lassen und diese dann abprüfen ob sie die Kriterien in 1.) erfüllen. Damit erhält man ein bessere Average Performance.

\subsection*{ Rückwerts }


\begin{gather}
    f(x, y) =  
    \begin{cases}
    	(2x, y - x)		\quad x < y \\
    	(x - y, 2y) 		\quad y < x
    \end{cases}
\end{gather}

So können wir die Umkehrfunktion bilden:

\begin{gather}
   	f^{-1}(x, y) =  
    \begin{cases}
    	(x + \frac{y}{2},  \frac{y}{2})		\quad x > y \wedge 0 \equiv y (mod 2) \\
    	(\frac{x}{2},y + \frac{x}{2})		\quad y > x\wedge 0 \equiv x (mod 2) \\
    	(\frac{x}{2}, y + \frac{x}{2})		\quad x > y \wedge 0 \equiv x (mod 2) \\
    	(x + \frac{y}{2}, \frac{y}{2})		\quad y > x\wedge 0 \equiv y (mod 2) \\
    \end{cases}
\end{gather}

Es fällt auf das die Funktion f(x, y) nicht eineindeutig ist ein Beispiel: \(f^{-1}(f(3, 5)) = (1, 7)  \text{or} (3,5) \)
Weil mehrere Kriterien der Funktion gleichzeitig erfüllt sein können gibt \(f^{-1}(x, y) \) nur ein paar zurück aber in der Implementierung würde darauf geachtet werden.

\subsection*{ Finden des Schwierigstens}

Ich habe dabei einen ähnliches Lösungsverfahren verwendet wie bei 1.) mit einem Baum wobei ich zuerst alle Paare gebildet habe:

N \dots Number of Items

\begin{equation}
	\forall n \in \mathbb{N}  \wedge 1 < N - n * 2, (n , n , N - n * 2)_n
\end{equation}

Das sind die Wurzeln des Baumes. Nun nehmen wir uns \(f^{-1}\) (5) zurhand und berechnen damit alle Äste (Kinder). Wobei Kinder nicht aufgenommen werden die schon tiefer im Baum existieren deswegen gibt es eine Such-Funktion.

Der Baum Generierung Prozess wird abgebrochen, wenn eine der äußeren Äste keine Kinder hatt (\(|childs| =. 0 \)) weil alle schon tiefer im Baum vorkommen diese Node ist dann die Node die zurückgegeben wird und mit der aktuell besten verglichen wird.

\section{ Implementierung }
Das Programm wurde mit C++ (C11) Implementiert das hat den Vorteil das ich meine Knoten als Objekte und den Parent und die Childs einfach als Pointer Speichern kann. Zudem habe ich den Großen Performance Vorteil, als kompilierte Sprache den ich definitiv brauche.

\subsection*{ Zum Laufen Kriegen }

Ich würde sehr dringend raten den gcc (g++) \(\rightarrow\) die GNU Build Essentials zu nutzen. Weil ich nicht dafür Garantieren kann das es z.B mit VSCODE oder clang geht. Die Cmake beinhaltet zwei Targets wobei Telepaartie\_1 die erste Teilaufgabe ist und Telepaartie\_2 die zweite. Ich habe mich für 2 Programme entschieden, um der GNU Philosophie zu folgen.

\begin{lstlisting}[language=Bash]
	
	$ mkdir build && cd build
	
	$ cmake ..
	
	$ make
	
	$ ./Telepaartie_1 2 4 7
	
	$./Telepaartie_2 63

\end{lstlisting}

\subsection*{ Der Baum }
clea
Die Knoten meines Programmes haben eine sind zwei Klassen TreeNodeForward und TreeNodeBackward die als Interface Klasse TreeNode besitzt durch zeitliche Schwierigkeiten konnte ich keine schöne klassenhierarchie aufbauen weswegen es auch so viel redundanten Code gibt den man in TreeNode einlagern hätte können. 


\end{document}