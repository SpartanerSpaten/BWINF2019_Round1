\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{amsmath}

%\graphicspath{ {../resources/} }

\begin{document}

\title{Telepaartie}
\author{Tassilo Tanneberger}

\maketitle

\section{Ideen des Algorithmus}

\subsection*{ Finden der LLL}

Eine LLL kann nur entstehen wenn dafor zwei Spalten die gleiche anzahl Objekte beinhalten(a,b,c \dots Spalten) \( a = b\) Somit würde auch gleich einen Schritt zufor gelten z.B 
\begin{equation}
	((2a = b \wedge a < c)  \oplus (2b = a \wedge b < c)) \oplus ((3a = b)  \oplus (3b = a))
\end{equation}

Mit diesem Wissen können wir Mögliche LLLs zwei Schichten vorraus sagen. Zudem möchte ich noch kurz darauf aufmerksam machen das \(a>c\) oder \(b > c\) bei  \( \leq \) würde Regel 1.) greifen. Diese Aufgestellten beobachtungen helfen uns nun die Zu untersuchenden Möglichkeite um zwei Schichten immer zu reduzieren.

\subsection*{ Darstellung als Baum}

Die einzig wirklich Sinnvolle Datenstrukturelle darstellung ist als Baum. Der folgende Eigenschaften besitzt.
\newline

\(max_c\)\dots 				Maximale Anzahl Kinder und Kanten die ein Knoten hatt. \newline
\(collumns\)\dots 			Anzahl Spalten ( Boxen ) \newline
\(max_k\)\dots				Maximale anzahl an Knoten.  \newline
\(N\)\dots    					Anzahl der Schichten bis LLL gefunden wird

\begin{equation}
	max_c =  \sum \limits_{i=0}^N  i
\end{equation}

Das sind natürlich nur worst case betrachtungen und mit intelligentem z.B Ausschließen von Doppelten lässt sich die gesamt anzahl Knoten stark minimieren. Somit ergibt sich für Anzahl der Knoten im gesamten Baum die Funktion: \newline

\begin{equation}
	max_k =  \sum \limits_{i=1}^N  (max_c ^ i)
\end{equation}

Wie schon im ersten Abschnitt angesprochen können wir das N um zwei Reduzieren weil wir schon nach den Kanten suchen die diese Eigenschaften erfüllen und somit auf Garantie zur LLL führen.

\subsection*{ Suchen }

Auch wenn die Datenstruktur "Baum" immer sehr einladend ist rekursiv zu Arbeiten (Suchen) ist sie für unseren fall hier äußerst ungeignet da wir damit sehr viele ungenutzte Knoten erzeugen was sehr unperformant ist. Weswegen wir alle Kinder aller Knoten einer Schicht erzeugen lassen und diese dann dann abprüfen ob sie die Kriterien in 1.) erfüllen. Damit erhältman ein bessere Average performance.


\subsection*{ Weitere Beobachtungen der Aufgabe }

\subsection*{ Formaler Ausdruck }


\begin{gather}
    f(x, y) =  
    \begin{cases}
    	(2x, y - x)		\quad x < y \\
    	(x - y, 2y) 		\quad y < x
    \end{cases}
\end{gather}

f is not fully periodical there a sometimes pair that come before periodical process starts. \newline

\(A_n\)\dots all possible Tuples (Pairs)
\begin{equation}
	A_n = \lbrace (x, y) \in D \mid f(x, y) \rbrace
\end{equation}
\begin{equation}
	A_n \cap A_k :\Longleftrightarrow \lbrace \rbrace \mid k \neq n
\end{equation}
%Daraus ergibt sich das jedes mögliche Zahlenpaar genau in einer Menge vorkommt.
We can conclude that every possible pair is member of exact one set. What happens now when we observe more than just x,y and add c we can this now describe as 3 pairs (x, y), (x, c), (y, c). The sets are staying the same. \newline

We will not introduce a category for sets which include a 0 as one of the two numbers
\begin{equation}
	(0, x) \in A_n \vee (x, 0) \in A_n
\end{equation}
These sets I will call null terminating.

Returning to the original question we are starting searching from all null terminating sets. Lets assume for demonstrational purposes that we have a sum of 9. Means we have four null terminating sequences ((0, 4) 5), ((0, 8),1), ((0, 2),7), ((0, 6),3) for the person woundering why its only 4 because the question requires that we make it hard for the solving algorithm and its impossible for the solving algo. to get too those other results.


\section{ Implementierung }
Das Programm wurde mit C++ (C11) Implementiert das ist hatt den Vorteil das ich meine Knoten als Objekte und den Parent und die Childs einfach als Pointer Speichern kann. Zudem habe ich den Großen Performance Vorteil als Complalierte Sprache den ich definitiv brauche.

\subsection*{ Zum Laufen Kriegen }

Ich würde sehr dringend raten den gcc (g++) \(\rightarrow\) die GNU Build Essentials zu nutzen. Weil ich nicht dafür Guarntieren kann das es z.B mit VSCODE oder clang geht.

\begin{lstlisting}[language=Bash]
	
	$ mkdir build && cd build
	
	$ cmake ..
	
	$ make
	
	$ ./Telepaartie 2 4 7

\end{lstlisting}

\subsection*{ Der Baum }

Die Knoten werden bei mir im Code durch die Klasse `TreeNode` repräsentiert. Sie speichert die aktuelle Configuration sowie den Parent und alle ihre Nachkommen. Zudem bietet die Klasse auch die oben besprochenen Methoden an sowas wie check (verweiß auf 1.1) oder generieren neuen nachkommen.


\end{document}